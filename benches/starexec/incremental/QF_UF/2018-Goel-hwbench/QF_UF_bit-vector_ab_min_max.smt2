(set-info :smt-lib-version 2.6)
(set-logic QF_UF)
(set-info :source |
Generated by: Aman Goel (amangoel@umich.edu), Karem A. Sakallah (karem@umich.edu)
Generated on: 2018-04-06

Generated by the tool Averroes 2 (successor of [1]) which implements safety property
verification on hardware systems.

This SMT problem belongs to a set of SMT problems generated by applying Averroes 2
to benchmarks derived from [2-5].

A total of 412 systems (345 from [2], 19 from [3], 26 from [4], 22 from [5]) were
syntactically converted from their original formats (using [6, 7]), and given to 
Averroes 2 to perform property checking with abstraction (wide bit-vectors -> terms, 
wide operators -> UF) using SMT solvers [8, 9].

[1] Lee S., Sakallah K.A. (2014) Unbounded Scalable Verification Based on Approximate
Property-Directed Reachability and Datapath Abstraction. In: Biere A., Bloem R. (eds)
Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559.
Springer, Cham
[2] http://fmv.jku.at/aiger/index.html#beem
[3] http://www.cs.cmu.edu/~modelcheck/vcegar
[4] http://www.cprover.org/hardware/v2c
[5] http://github.com/aman-goel/verilogbench
[6] http://www.clifford.at/yosys
[7] http://github.com/chengyinwu/V3
[8] http://github.com/Z3Prover/z3
[9] http://github.com/SRI-CSL/yices2

id: bit-vector
query-maker: "Z3"
query-time: 0.480000 ms
query-class: abstract
query-category: assume
query-type: mus_min
status: sat
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")

; 
(set-info :status sat)
(declare-sort utt2 0)
(declare-sort utt3 0)
(declare-sort utt32 0)
(declare-sort utt29 0)
(declare-fun z$n2s2 () utt2)
(declare-fun z$n1s2 () utt2)
(declare-fun z$n3s2 () utt2)
(declare-fun z$n1s3 () utt3)
(declare-fun z$n4s3 () utt3)
(declare-fun z$n0s3 () utt3)
(declare-fun z$n3s3 () utt3)
(declare-fun z$n6s3 () utt3)
(declare-fun z$n2s3 () utt3)
(declare-fun z$n4s32 () utt32)
(declare-fun z$n2147483648s32 () utt32)
(declare-fun z$n1s32 () utt32)
(declare-fun z$n3s32 () utt32)
(declare-fun z$n0s32 () utt32)
(declare-fun z$n2s32 () utt32)
(declare-fun b () utt3)
(declare-fun Concat_32_3_29 (utt3 utt29) utt32)
(declare-fun z$n0s29 () utt29)
(declare-fun a () utt3)
(declare-fun z$26 () utt32)
(declare-fun a$next () utt3)
(declare-fun z$40 () utt32)
(declare-fun Extract_2_2_1_3 (utt3) utt2)
(declare-fun z$8 () utt2)
(declare-fun Concat_3_2_1 (utt2 Bool) utt3)
(declare-fun z$12 () utt3)
(declare-fun Extract_2_1_0_3 (utt3) utt2)
(declare-fun z$18 () utt2)
(declare-fun Concat_3_1_2 (Bool utt2) utt3)
(declare-fun z$20 () utt3)
(declare-fun b$next () utt3)
(declare-fun z$134 () utt2)
(declare-fun z$136 () utt3)
(declare-fun z$94 () utt2)
(declare-fun z$97 () utt3)
(declare-fun z$113 () Bool)
(declare-fun z$170 () Bool)
(declare-fun z$309 () Bool)
(declare-fun z$310 () Bool)
(declare-fun GrEq_1_32_32 (utt32 utt32) Bool)
(declare-fun z$29 () Bool)
(declare-fun prop () Bool)
(declare-fun z$31 () Bool)
(declare-fun z$42 () Bool)
(declare-fun prop$next () Bool)
(declare-fun z$44 () Bool)
(declare-fun z$54 () Bool)
(declare-fun z$55 () Bool)
(declare-fun z$56 () Bool)
(declare-fun z$58 () Bool)
(declare-fun z$2 () Bool)
(declare-fun z$50 () Bool)
(declare-fun z$53 () Bool)
(declare-fun z$57 () Bool)
(declare-fun z$76 () Bool)
(declare-fun z$62 () Bool)
(declare-fun z$77 () Bool)
(declare-fun z$79 () Bool)
(declare-fun z$46 () Bool)
(declare-fun z$70 () Bool)
(declare-fun z$75 () Bool)
(declare-fun z$78 () Bool)
(declare-fun Extract_1_0_0_3 (utt3) Bool)
(declare-fun z$10 () Bool)
(declare-fun z$14 () Bool)
(declare-fun z$5 () Bool)
(declare-fun z$108 () Bool)
(declare-fun z$109 () Bool)
(declare-fun z$158 () Bool)
(declare-fun z$166 () Bool)
(declare-fun z$167 () Bool)
(declare-fun Extract_1_2_2_3 (utt3) Bool)
(declare-fun z$16 () Bool)
(declare-fun z$22 () Bool)
(declare-fun z$179 () Bool)
(declare-fun z$189 () Bool)
(declare-fun z$190 () Bool)
(declare-fun z$257 () Bool)
(declare-fun z$258 () Bool)
(declare-fun z$131 () Bool)
(declare-fun z$268 () Bool)
(declare-fun z$282 () Bool)
(declare-fun z$283 () Bool)
(declare-fun z$266 () Bool)
(declare-fun z$325 () Bool)
(declare-fun z$326 () Bool)
(declare-fun z$357 () Bool)
(declare-fun z$358 () Bool)
(declare-fun z$365 () Bool)
(declare-fun z$261 () Bool)
(declare-fun z$130 () Bool)
(declare-fun z$92 () Bool)
(declare-fun z$93 () Bool)
(declare-fun z$381 () Bool)
(declare-fun z$382 () Bool)
(declare-fun z$132 () Bool)
(declare-fun z$401 () Bool)
(declare-fun z$415 () Bool)
(declare-fun z$417 () Bool)
(declare-fun z$85 () Bool)
(declare-fun z$400 () Bool)
(declare-fun z$414 () Bool)
(declare-fun z$416 () Bool)
(declare-fun z$396 () Bool)
(declare-fun z$438 () Bool)
(declare-fun z$439 () Bool)
(declare-fun z$6 () Bool)
(declare-fun z$203 () Bool)
(declare-fun z$385 () Bool)
(declare-fun z$454 () Bool)
(declare-fun z$455 () Bool)
(declare-fun z$388 () Bool)
(declare-fun z$99 () Bool)
(declare-fun z$468 () Bool)
(declare-fun z$469 () Bool)
(declare-fun z$482 () Bool)
(declare-fun p$0 () Bool)
(declare-fun p$1 () Bool)
(declare-fun p$2 () Bool)
(declare-fun p$3 () Bool)
(assert
 (and (distinct z$n3s2 z$n1s2 z$n2s2) true))
(assert
 (and (distinct z$n2s3 z$n6s3 z$n3s3 z$n0s3 z$n4s3 z$n1s3) true))
(assert
 (and (distinct z$n2s32 z$n0s32 z$n3s32 z$n1s32 z$n2147483648s32 z$n4s32) true))
(assert
 (= z$113 (and (distinct b z$n6s3) true)))
(assert
 (= z$170 (and (distinct b z$n4s3) true)))
(assert
 (= z$309 (and z$113 z$170)))
(assert
 (= z$310 (not z$309)))
(assert
 (let ((?x167 (Concat_32_3_29 a z$n0s29)))
 (= z$26 ?x167)))
(assert
 (let (($x160 (GrEq_1_32_32 z$26 z$n2s32)))
 (= z$29 $x160)))
(assert
 (= z$31 (= prop z$29)))
(assert
 (let ((?x360 (Concat_32_3_29 a$next z$n0s29)))
 (= z$40 ?x360)))
(assert
 (let (($x437 (GrEq_1_32_32 z$40 z$n2s32)))
 (= z$42 $x437)))
(assert
 (= z$44 (= prop$next z$42)))
(assert
 (let (($x378 (= a$next z$n2s3)))
 (= z$54 $x378)))
(assert
 (= z$55 (and (distinct z$40 z$n2s32) true)))
(assert
 (= z$56 (and z$54 z$55)))
(assert
 (= z$58 (not z$56)))
(assert
 (let (($x489 (= a z$n2s3)))
 (= z$2 $x489)))
(assert
 (= z$50 (and (distinct z$26 z$n2s32) true)))
(assert
 (= z$53 (and z$2 z$50)))
(assert
 (= z$57 (not z$53)))
(assert
 (let (($x639 (not z$42)))
 (= z$76 $x639)))
(assert
 (let (($x477 (= z$40 z$n2s32)))
 (= z$62 $x477)))
(assert
 (= z$77 (and z$76 z$62)))
(assert
 (= z$79 (not z$77)))
(assert
 (= z$46 (not z$29)))
(assert
 (let (($x567 (= z$26 z$n2s32)))
 (= z$70 $x567)))
(assert
 (= z$75 (and z$46 z$70)))
(assert
 (= z$78 (not z$75)))
(assert
 (let ((?x328 (Extract_2_2_1_3 b)))
 (= z$8 ?x328)))
(assert
 (let (($x345 (Extract_1_0_0_3 b)))
 (= z$10 $x345)))
(assert
 (let ((?x816 (Concat_3_2_1 z$8 z$10)))
 (= z$12 ?x816)))
(assert
 (let (($x782 (= a$next z$12)))
 (= z$14 $x782)))
(assert
 (let (($x571 (= b z$n6s3)))
 (= z$5 $x571)))
(assert
 (= z$108 (and z$14 z$5 z$76)))
(assert
 (= z$109 (not z$108)))
(assert
 (let (($x703 (= b z$n4s3)))
 (= z$158 $x703)))
(assert
 (= z$166 (and z$158 z$55 z$14)))
(assert
 (= z$167 (not z$166)))
(assert
 (let (($x549 (Extract_1_2_2_3 a)))
 (= z$16 $x549)))
(assert
 (let ((?x547 (Extract_2_1_0_3 a)))
 (= z$18 ?x547)))
(assert
 (let ((?x545 (Concat_3_1_2 z$16 z$18)))
 (= z$20 ?x545)))
(assert
 (let (($x537 (= b$next z$20)))
 (= z$22 $x537)))
(assert
 (= z$179 (and (distinct b$next z$n4s3) true)))
(assert
 (= z$189 (and z$22 z$179 z$2)))
(assert
 (= z$190 (not z$189)))
(assert
 (= z$257 (and z$5 z$76 z$14)))
(assert
 (= z$258 (not z$257)))
(assert
 (let (($x817 (Extract_1_2_2_3 a$next)))
 (= z$131 $x817)))
(assert
 (let ((?x1000 (Extract_2_1_0_3 a$next)))
 (= z$134 ?x1000)))
(assert
 (let ((?x1367 (Concat_3_1_2 z$131 z$134)))
 (= z$136 ?x1367)))
(assert
 (= z$268 (and (distinct z$136 z$n6s3) true)))
(assert
 (= z$282 (and z$14 z$268 z$5)))
(assert
 (= z$283 (not z$282)))
(assert
 (= z$266 (and (distinct z$20 z$n6s3) true)))
(assert
 (= z$325 (and z$158 z$266)))
(assert
 (= z$326 (not z$325)))
(assert
 (= z$357 (and z$2 z$179 z$22)))
(assert
 (= z$358 (not z$357)))
(assert
 (= z$365 (and (distinct z$20 z$n2s3) true)))
(assert
 (= z$261 (and (distinct b$next z$n6s3) true)))
(assert
 (= z$130 (and (distinct a z$20) true)))
(assert
 (let (($x312 (Extract_1_0_0_3 b$next)))
 (= z$92 $x312)))
(assert
 (= z$93 (not z$92)))
(assert
 (= z$381 (and z$22 z$365 z$261 z$179 z$130 z$93)))
(assert
 (= z$382 (not z$381)))
(assert
 (= z$132 (not z$131)))
(assert
 (let (($x772 (= a$next z$n6s3)))
 (= z$401 $x772)))
(assert
 (= z$415 (and z$132 z$401)))
(assert
 (= z$417 (not z$415)))
(assert
 (= z$85 (not z$16)))
(assert
 (let (($x1339 (= a z$n6s3)))
 (= z$400 $x1339)))
(assert
 (= z$414 (and z$85 z$400)))
(assert
 (= z$416 (not z$414)))
(assert
 (let (($x2057 (= z$136 z$n2s3)))
 (= z$396 $x2057)))
(assert
 (= z$438 (and z$14 z$396 z$158)))
(assert
 (= z$439 (not z$438)))
(assert
 (= z$6 (and z$2 z$5)))
(assert
 (= z$203 (not z$6)))
(assert
 (let (($x1968 (= z$20 z$n2s3)))
 (= z$385 $x1968)))
(assert
 (= z$454 (and z$203 z$385)))
(assert
 (= z$455 (not z$454)))
(assert
 (let (($x954 (= a z$20)))
 (= z$388 $x954)))
(assert
 (let ((?x526 (Extract_2_2_1_3 b$next)))
 (= z$94 ?x526)))
(assert
 (let ((?x1862 (Concat_3_2_1 z$94 z$92)))
 (= z$97 ?x1862)))
(assert
 (= z$99 (and (distinct b$next z$97) true)))
(assert
 (= z$468 (and z$22 z$388 z$99)))
(assert
 (= z$469 (not z$468)))
(assert
 (let (($x1271 (and z$310 z$31 prop z$44 z$58 z$57 z$79 z$78 z$109 z$167 z$190 z$258 z$283 z$22 z$326 z$358 z$14 z$382 z$417 z$416 z$439 z$455 z$469)))
 (= z$482 $x1271)))
(assert
 z$482)
(assert
 (let (($x312 (Extract_1_0_0_3 b$next)))
 (let (($x206 (= z$92 $x312)))
 (=> p$0 $x206))))
(assert
 (let (($x340 (= z$93 (not z$92))))
 (=> p$0 $x340)))
(assert
 (=> p$0 z$93))
(assert
 (let ((?x526 (Extract_2_2_1_3 b$next)))
 (let (($x1767 (= z$94 ?x526)))
 (=> p$1 $x1767))))
(assert
 (let (($x312 (Extract_1_0_0_3 b$next)))
 (let (($x206 (= z$92 $x312)))
 (=> p$1 $x206))))
(assert
 (let ((?x1862 (Concat_3_2_1 z$94 z$92)))
 (let (($x1865 (= z$97 ?x1862)))
 (=> p$1 $x1865))))
(assert
 (let (($x643 (= z$99 (and (distinct b$next z$97) true))))
 (=> p$1 $x643)))
(assert
 (=> p$1 z$99))
(assert
 (let (($x323 (= z$179 (and (distinct b$next z$n4s3) true))))
 (=> p$2 $x323)))
(assert
 (=> p$2 z$179))
(assert
 (let (($x663 (= z$261 (and (distinct b$next z$n6s3) true))))
 (=> p$3 $x663)))
(assert
 (=> p$3 z$261))
(check-sat)
(assert p$2)
(assert p$0)
(assert p$3)
(set-info :status sat)
(check-sat)
(exit)
