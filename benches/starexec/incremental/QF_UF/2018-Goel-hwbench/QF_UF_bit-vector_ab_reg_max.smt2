(set-info :smt-lib-version 2.6)
(set-logic QF_UF)
(set-info :source |
Generated by: Aman Goel (amangoel@umich.edu), Karem A. Sakallah (karem@umich.edu)
Generated on: 2018-04-06

Generated by the tool Averroes 2 (successor of [1]) which implements safety property
verification on hardware systems.

This SMT problem belongs to a set of SMT problems generated by applying Averroes 2
to benchmarks derived from [2-5].

A total of 412 systems (345 from [2], 19 from [3], 26 from [4], 22 from [5]) were
syntactically converted from their original formats (using [6, 7]), and given to 
Averroes 2 to perform property checking with abstraction (wide bit-vectors -> terms, 
wide operators -> UF) using SMT solvers [8, 9].

[1] Lee S., Sakallah K.A. (2014) Unbounded Scalable Verification Based on Approximate
Property-Directed Reachability and Datapath Abstraction. In: Biere A., Bloem R. (eds)
Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559.
Springer, Cham
[2] http://fmv.jku.at/aiger/index.html#beem
[3] http://www.cs.cmu.edu/~modelcheck/vcegar
[4] http://www.cprover.org/hardware/v2c
[5] http://github.com/aman-goel/verilogbench
[6] http://www.clifford.at/yosys
[7] http://github.com/chengyinwu/V3
[8] http://github.com/Z3Prover/z3
[9] http://github.com/SRI-CSL/yices2

id: bit-vector
query-maker: "Z3"
query-time: 0.267000 ms
query-class: abstract
query-category: assume
query-type: regular
status: sat
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")

; 
(set-info :status sat)
(declare-sort utt2 0)
(declare-sort utt3 0)
(declare-sort utt32 0)
(declare-sort utt29 0)
(declare-fun z$n2s2 () utt2)
(declare-fun z$n1s2 () utt2)
(declare-fun z$n3s2 () utt2)
(declare-fun z$n1s3 () utt3)
(declare-fun z$n4s3 () utt3)
(declare-fun z$n0s3 () utt3)
(declare-fun z$n3s3 () utt3)
(declare-fun z$n6s3 () utt3)
(declare-fun z$n2s3 () utt3)
(declare-fun z$n1s32 () utt32)
(declare-fun z$n3s32 () utt32)
(declare-fun z$n0s32 () utt32)
(declare-fun z$n2s32 () utt32)
(declare-fun a () utt3)
(declare-fun Extract_2_1_0_3 (utt3) utt2)
(declare-fun z$18 () utt2)
(declare-fun Concat_3_1_2 (Bool utt2) utt3)
(declare-fun z$20 () utt3)
(declare-fun b$next () utt3)
(declare-fun a$next () utt3)
(declare-fun Concat_32_3_29 (utt3 utt29) utt32)
(declare-fun z$n0s29 () utt29)
(declare-fun z$40 () utt32)
(declare-fun z$26 () utt32)
(declare-fun Extract_2_2_1_3 (utt3) utt2)
(declare-fun b () utt3)
(declare-fun z$8 () utt2)
(declare-fun Concat_3_2_1 (utt2 Bool) utt3)
(declare-fun z$12 () utt3)
(declare-fun Extract_1_2_2_3 (utt3) Bool)
(declare-fun z$16 () Bool)
(declare-fun z$22 () Bool)
(declare-fun z$54 () Bool)
(declare-fun z$55 () Bool)
(declare-fun z$56 () Bool)
(declare-fun z$58 () Bool)
(declare-fun z$2 () Bool)
(declare-fun z$50 () Bool)
(declare-fun z$53 () Bool)
(declare-fun z$57 () Bool)
(declare-fun GrEq_1_32_32 (utt32 utt32) Bool)
(declare-fun z$42 () Bool)
(declare-fun z$76 () Bool)
(declare-fun z$62 () Bool)
(declare-fun z$77 () Bool)
(declare-fun z$79 () Bool)
(declare-fun z$29 () Bool)
(declare-fun z$46 () Bool)
(declare-fun z$70 () Bool)
(declare-fun z$75 () Bool)
(declare-fun z$78 () Bool)
(declare-fun Extract_1_0_0_3 (utt3) Bool)
(declare-fun z$10 () Bool)
(declare-fun z$14 () Bool)
(declare-fun z$5 () Bool)
(declare-fun z$108 () Bool)
(declare-fun z$109 () Bool)
(declare-fun z$158 () Bool)
(declare-fun z$166 () Bool)
(declare-fun z$167 () Bool)
(declare-fun z$179 () Bool)
(declare-fun z$189 () Bool)
(declare-fun z$190 () Bool)
(declare-fun z$255 () Bool)
(declare-fun prop$next () Bool)
(declare-fun z$39 () Bool)
(declare-fun p$0 () Bool)
(declare-fun p$1 () Bool)
(declare-fun z$84 () Bool)
(declare-fun p$2 () Bool)
(declare-fun z$91 () Bool)
(declare-fun p$3 () Bool)
(declare-fun p$4 () Bool)
(declare-fun p$5 () Bool)
(declare-fun p$6 () Bool)
(declare-fun p$7 () Bool)
(declare-fun z$86 () Bool)
(declare-fun z$170 () Bool)
(declare-fun p$8 () Bool)
(assert
 (and (distinct z$n3s2 z$n1s2 z$n2s2) true))
(assert
 (and (distinct z$n2s3 z$n6s3 z$n3s3 z$n0s3 z$n4s3 z$n1s3) true))
(assert
 (and (distinct z$n2s32 z$n0s32 z$n3s32 z$n1s32) true))
(assert
 (let (($x549 (Extract_1_2_2_3 a)))
 (= z$16 $x549)))
(assert
 (let ((?x547 (Extract_2_1_0_3 a)))
 (= z$18 ?x547)))
(assert
 (let ((?x545 (Concat_3_1_2 z$16 z$18)))
 (= z$20 ?x545)))
(assert
 (let (($x537 (= b$next z$20)))
 (= z$22 $x537)))
(assert
 (let (($x378 (= a$next z$n2s3)))
 (= z$54 $x378)))
(assert
 (let ((?x360 (Concat_32_3_29 a$next z$n0s29)))
 (= z$40 ?x360)))
(assert
 (= z$55 (and (distinct z$40 z$n2s32) true)))
(assert
 (= z$56 (and z$54 z$55)))
(assert
 (= z$58 (not z$56)))
(assert
 (let (($x489 (= a z$n2s3)))
 (= z$2 $x489)))
(assert
 (let ((?x167 (Concat_32_3_29 a z$n0s29)))
 (= z$26 ?x167)))
(assert
 (= z$50 (and (distinct z$26 z$n2s32) true)))
(assert
 (= z$53 (and z$2 z$50)))
(assert
 (= z$57 (not z$53)))
(assert
 (let (($x437 (GrEq_1_32_32 z$40 z$n2s32)))
 (= z$42 $x437)))
(assert
 (let (($x639 (not z$42)))
 (= z$76 $x639)))
(assert
 (let (($x477 (= z$40 z$n2s32)))
 (= z$62 $x477)))
(assert
 (= z$77 (and z$76 z$62)))
(assert
 (= z$79 (not z$77)))
(assert
 (let (($x160 (GrEq_1_32_32 z$26 z$n2s32)))
 (= z$29 $x160)))
(assert
 (= z$46 (not z$29)))
(assert
 (let (($x567 (= z$26 z$n2s32)))
 (= z$70 $x567)))
(assert
 (= z$75 (and z$46 z$70)))
(assert
 (= z$78 (not z$75)))
(assert
 (let ((?x328 (Extract_2_2_1_3 b)))
 (= z$8 ?x328)))
(assert
 (let (($x345 (Extract_1_0_0_3 b)))
 (= z$10 $x345)))
(assert
 (let ((?x816 (Concat_3_2_1 z$8 z$10)))
 (= z$12 ?x816)))
(assert
 (let (($x782 (= a$next z$12)))
 (= z$14 $x782)))
(assert
 (let (($x571 (= b z$n6s3)))
 (= z$5 $x571)))
(assert
 (= z$108 (and z$14 z$5 z$76)))
(assert
 (= z$109 (not z$108)))
(assert
 (let (($x703 (= b z$n4s3)))
 (= z$158 $x703)))
(assert
 (= z$166 (and z$158 z$55 z$14)))
(assert
 (= z$167 (not z$166)))
(assert
 (= z$179 (and (distinct b$next z$n4s3) true)))
(assert
 (= z$189 (and z$22 z$179 z$2)))
(assert
 (= z$190 (not z$189)))
(assert
 (let (($x1302 (and z$22 z$58 z$57 z$79 z$78 z$109 z$167 z$190 z$14)))
 (= z$255 $x1302)))
(assert
 z$255)
(assert
 (let (($x1442 (= z$39 (not prop$next))))
 (=> p$0 $x1442)))
(assert
 (=> p$0 z$39))
(assert
 (let (($x345 (Extract_1_0_0_3 b)))
 (let (($x623 (= z$10 $x345)))
 (=> p$1 $x623))))
(assert
 (let (($x1278 (= z$84 (not z$10))))
 (=> p$1 $x1278)))
(assert
 (=> p$1 z$84))
(assert
 (let ((?x328 (Extract_2_2_1_3 b)))
 (let (($x574 (= z$8 ?x328)))
 (=> p$2 $x574))))
(assert
 (let (($x345 (Extract_1_0_0_3 b)))
 (let (($x623 (= z$10 $x345)))
 (=> p$2 $x623))))
(assert
 (let ((?x816 (Concat_3_2_1 z$8 z$10)))
 (let (($x502 (= z$12 ?x816)))
 (=> p$2 $x502))))
(assert
 (let (($x610 (= z$91 (and (distinct b z$12) true))))
 (=> p$2 $x610)))
(assert
 (=> p$2 z$91))
(assert
 (let (($x489 (= a z$n2s3)))
 (let (($x144 (= z$2 $x489)))
 (=> p$3 $x144))))
(assert
 (=> p$3 z$2))
(assert
 (let (($x571 (= b z$n6s3)))
 (let (($x458 (= z$5 $x571)))
 (=> p$4 $x458))))
(assert
 (=> p$4 z$5))
(assert
 (let ((?x360 (Concat_32_3_29 a$next z$n0s29)))
 (let (($x362 (= z$40 ?x360)))
 (=> p$5 $x362))))
(assert
 (let (($x66 (= z$55 (and (distinct z$40 z$n2s32) true))))
 (=> p$5 $x66)))
(assert
 (=> p$5 z$55))
(assert
 (let ((?x360 (Concat_32_3_29 a$next z$n0s29)))
 (let (($x362 (= z$40 ?x360)))
 (=> p$6 $x362))))
(assert
 (let (($x437 (GrEq_1_32_32 z$40 z$n2s32)))
 (let (($x366 (= z$42 $x437)))
 (=> p$6 $x366))))
(assert
 (let (($x639 (not z$42)))
 (let (($x281 (= z$76 $x639)))
 (=> p$6 $x281))))
(assert
 (=> p$6 z$76))
(assert
 (let ((?x360 (Concat_32_3_29 a$next z$n0s29)))
 (let (($x362 (= z$40 ?x360)))
 (=> p$7 $x362))))
(assert
 (let (($x437 (GrEq_1_32_32 z$40 z$n2s32)))
 (let (($x366 (= z$42 $x437)))
 (=> p$7 $x366))))
(assert
 (let (($x639 (not z$42)))
 (let (($x648 (= z$86 $x639)))
 (=> p$7 $x648))))
(assert
 (=> p$7 z$86))
(assert
 (let (($x877 (= z$170 (and (distinct b z$n4s3) true))))
 (=> p$8 $x877)))
(assert
 (=> p$8 z$170))
(check-sat)
(assert p$6)
(set-info :status sat)
(check-sat)
(exit)
