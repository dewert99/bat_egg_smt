(set-info :smt-lib-version 2.6)
(set-logic QF_UF)
(set-info :source |
Generated by: Aman Goel (amangoel@umich.edu), Karem A. Sakallah (karem@umich.edu)
Generated on: 2018-04-06

Generated by the tool Averroes 2 (successor of [1]) which implements safety property
verification on hardware systems.

This SMT problem belongs to a set of SMT problems generated by applying Averroes 2
to benchmarks derived from [2-5].

A total of 412 systems (345 from [2], 19 from [3], 26 from [4], 22 from [5]) were
syntactically converted from their original formats (using [6, 7]), and given to 
Averroes 2 to perform property checking with abstraction (wide bit-vectors -> terms, 
wide operators -> UF) using SMT solvers [8, 9].

[1] Lee S., Sakallah K.A. (2014) Unbounded Scalable Verification Based on Approximate
Property-Directed Reachability and Datapath Abstraction. In: Biere A., Bloem R. (eds)
Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559.
Springer, Cham
[2] http://fmv.jku.at/aiger/index.html#beem
[3] http://www.cs.cmu.edu/~modelcheck/vcegar
[4] http://www.cprover.org/hardware/v2c
[5] http://github.com/aman-goel/verilogbench
[6] http://www.clifford.at/yosys
[7] http://github.com/chengyinwu/V3
[8] http://github.com/Z3Prover/z3
[9] http://github.com/SRI-CSL/yices2

id: eq_sdp_v5
query-maker: "Z3"
query-time: 0.696000 ms
query-class: abstract
query-category: assume
query-type: mus_core
status: unsat
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")

; 
(set-info :status sat)
(declare-sort utt8 0)
(declare-fun z$n1s8 () utt8)
(declare-fun z$n0s8 () utt8)
(declare-fun im.p1_a () utt8)
(declare-fun im.p1_b () utt8)
(declare-fun im.p1_c () utt8)
(declare-fun im.p2_c () utt8)
(declare-fun im.p2_m () utt8)
(declare-fun im.p3_n () utt8)
(declare-fun s1 () utt8)
(declare-fun s2 () utt8)
(declare-fun s3 () utt8)
(declare-fun im.p3_n$next () utt8)
(declare-fun s3$next () utt8)
(declare-fun Sub_8_8_8 (utt8 utt8) utt8)
(declare-fun im.p2_c$next () utt8)
(declare-fun im.p2_m$next () utt8)
(declare-fun z$137 () utt8)
(declare-fun s2$next () utt8)
(declare-fun z$95 () utt8)
(declare-fun z$48 () utt8)
(declare-fun BitWiseAnd_8_8_8 (utt8 utt8) utt8)
(declare-fun z$78 () utt8)
(declare-fun Add_8_8_8 (utt8 utt8) utt8)
(declare-fun z$81 () utt8)
(declare-fun z$83 () utt8)
(declare-fun z$85 () utt8)
(declare-fun z$87 () utt8)
(declare-fun z$91 () utt8)
(declare-fun z$2 () Bool)
(declare-fun z$4 () Bool)
(declare-fun z$6 () Bool)
(declare-fun im.p1_ctl_2 () Bool)
(declare-fun z$8 () Bool)
(declare-fun z$10 () Bool)
(declare-fun im.p2_ctl_2 () Bool)
(declare-fun z$12 () Bool)
(declare-fun z$14 () Bool)
(declare-fun z$16 () Bool)
(declare-fun z$18 () Bool)
(declare-fun z$20 () Bool)
(declare-fun z$22 () Bool)
(declare-fun z$102 () Bool)
(declare-fun prop () Bool)
(declare-fun z$103 () Bool)
(declare-fun z$116 () Bool)
(declare-fun prop$next () Bool)
(declare-fun z$117 () Bool)
(declare-fun z$139 () Bool)
(declare-fun z$146 () Bool)
(declare-fun z$147 () Bool)
(declare-fun z$148 () Bool)
(declare-fun z$149 () Bool)
(declare-fun z$151 () Bool)
(declare-fun z$133 () Bool)
(declare-fun z$145 () Bool)
(declare-fun z$150 () Bool)
(declare-fun im.reset () Bool)
(declare-fun z$50 () Bool)
(declare-fun z$80 () Bool)
(declare-fun z$89 () Bool)
(declare-fun z$93 () Bool)
(declare-fun im.reset$next () Bool)
(declare-fun z$134 () Bool)
(declare-fun p$0 () Bool)
(declare-fun p$1 () Bool)
(declare-fun z$181 () Bool)
(declare-fun p$2 () Bool)
(declare-fun z$182 () Bool)
(declare-fun p$3 () Bool)
(declare-fun p$4 () Bool)
(declare-fun z$183 () Bool)
(declare-fun p$5 () Bool)
(declare-fun z$184 () Bool)
(declare-fun z$185 () Bool)
(declare-fun p$6 () Bool)
(assert
 (and (distinct z$n0s8 z$n1s8) true))
(assert
 (let (($x813 (= im.p1_a z$n0s8)))
 (= z$2 $x813)))
(assert
 z$2)
(assert
 (let (($x306 (= im.p1_b z$n0s8)))
 (= z$4 $x306)))
(assert
 z$4)
(assert
 (let (($x856 (= im.p1_c z$n0s8)))
 (= z$6 $x856)))
(assert
 z$6)
(assert
 (= z$8 (not im.p1_ctl_2)))
(assert
 z$8)
(assert
 (let (($x405 (= im.p2_c z$n0s8)))
 (= z$10 $x405)))
(assert
 z$10)
(assert
 (= z$12 (not im.p2_ctl_2)))
(assert
 z$12)
(assert
 (let (($x31 (= im.p2_m z$n0s8)))
 (= z$14 $x31)))
(assert
 z$14)
(assert
 (let (($x851 (= im.p3_n z$n0s8)))
 (= z$16 $x851)))
(assert
 z$16)
(assert
 (let (($x478 (= s1 z$n0s8)))
 (= z$18 $x478)))
(assert
 z$18)
(assert
 (let (($x47 (= s2 z$n0s8)))
 (= z$20 $x47)))
(assert
 z$20)
(assert
 (let (($x902 (= s3 z$n0s8)))
 (= z$22 $x902)))
(assert
 z$22)
(assert
 (let (($x221 (= s3 im.p3_n)))
 (= z$102 $x221)))
(assert
 (= z$103 (= prop z$102)))
(assert
 z$103)
(assert
 prop)
(assert
 (let (($x189 (= s3$next im.p3_n$next)))
 (= z$116 $x189)))
(assert
 (= z$117 (= prop$next z$116)))
(assert
 z$117)
(assert
 (let ((?x160 (Sub_8_8_8 im.p2_m$next im.p2_c$next)))
 (= z$137 ?x160)))
(assert
 (= z$139 (and (distinct s2$next z$137) true)))
(assert
 (let (($x134 (= s2$next z$n0s8)))
 (= z$146 $x134)))
(assert
 (let (($x124 (= im.p2_m$next z$n0s8)))
 (= z$147 $x124)))
(assert
 (let (($x114 (= im.p2_c$next z$n0s8)))
 (= z$148 $x114)))
(assert
 (= z$149 (and z$139 z$146 z$147 z$148)))
(assert
 (= z$151 (not z$149)))
(assert
 z$151)
(assert
 (let ((?x78 (Sub_8_8_8 im.p2_m im.p2_c)))
 (= z$95 ?x78)))
(assert
 (= z$133 (and (distinct s2 z$95) true)))
(assert
 (= z$145 (and z$133 z$20 z$14 z$10)))
(assert
 (= z$150 (not z$145)))
(assert
 z$150)
(assert
 (let ((?x265 (ite im.reset z$n0s8 s1)))
 (= z$48 ?x265)))
(assert
 (let (($x594 (= s2$next z$48)))
 (= z$50 $x594)))
(assert
 z$50)
(assert
 (let ((?x932 (BitWiseAnd_8_8_8 im.p1_a z$n1s8)))
 (= z$78 ?x932)))
(assert
 (let (($x930 (= z$78 z$n1s8)))
 (= z$80 $x930)))
(assert
 (let ((?x618 (Add_8_8_8 im.p1_a im.p1_b)))
 (= z$81 ?x618)))
(assert
 (let ((?x616 (Sub_8_8_8 im.p1_a im.p1_b)))
 (= z$83 ?x616)))
(assert
 (let ((?x614 (ite z$80 z$81 z$83)))
 (= z$85 ?x614)))
(assert
 (let ((?x622 (ite im.reset z$n0s8 z$85)))
 (= z$87 ?x622)))
(assert
 (let (($x630 (= im.p2_m$next z$87)))
 (= z$89 $x630)))
(assert
 z$89)
(assert
 (let ((?x232 (ite im.reset z$n0s8 im.p1_c)))
 (= z$91 ?x232)))
(assert
 (let (($x235 (= im.p2_c$next z$91)))
 (= z$93 $x235)))
(assert
 z$93)
(assert
 (=> p$0 (= z$134 (not im.reset$next))))
(assert
 (=> p$0 z$134))
(assert
 (let ((?x160 (Sub_8_8_8 im.p2_m$next im.p2_c$next)))
 (let (($x152 (= z$137 ?x160)))
 (=> p$1 $x152))))
(assert
 (let (($x142 (= z$139 (and (distinct s2$next z$137) true))))
 (=> p$1 $x142)))
(assert
 (=> p$1 z$139))
(assert
 (=> p$2 (= z$181 (and (distinct s2$next im.p2_m$next) true))))
(assert
 (=> p$2 z$181))
(assert
 (=> p$3 (= z$182 (and (distinct s2$next im.p2_c$next) true))))
(assert
 (=> p$3 z$182))
(assert
 (let ((?x160 (Sub_8_8_8 im.p2_m$next im.p2_c$next)))
 (let (($x152 (= z$137 ?x160)))
 (=> p$4 $x152))))
(assert
 (=> p$4 (= z$183 (and (distinct z$137 im.p2_m$next) true))))
(assert
 (=> p$4 z$183))
(assert
 (let ((?x160 (Sub_8_8_8 im.p2_m$next im.p2_c$next)))
 (let (($x152 (= z$137 ?x160)))
 (=> p$5 $x152))))
(assert
 (=> p$5 (= z$184 (and (distinct z$137 im.p2_c$next) true))))
(assert
 (=> p$5 z$184))
(assert
 (=> p$6 (= z$185 (and (distinct im.p2_m$next im.p2_c$next) true))))
(assert
 (=> p$6 z$185))
(check-sat)
(assert p$0)
(assert p$1)
(assert p$2)
(assert p$3)
(assert p$4)
(assert p$5)
(assert p$6)
(set-info :status unsat)
(check-sat)
(exit)
