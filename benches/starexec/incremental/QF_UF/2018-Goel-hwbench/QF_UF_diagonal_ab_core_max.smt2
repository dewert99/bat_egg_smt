(set-info :smt-lib-version 2.6)
(set-logic QF_UF)
(set-info :source |
Generated by: Aman Goel (amangoel@umich.edu), Karem A. Sakallah (karem@umich.edu)
Generated on: 2018-04-06

Generated by the tool Averroes 2 (successor of [1]) which implements safety property
verification on hardware systems.

This SMT problem belongs to a set of SMT problems generated by applying Averroes 2
to benchmarks derived from [2-5].

A total of 412 systems (345 from [2], 19 from [3], 26 from [4], 22 from [5]) were
syntactically converted from their original formats (using [6, 7]), and given to 
Averroes 2 to perform property checking with abstraction (wide bit-vectors -> terms, 
wide operators -> UF) using SMT solvers [8, 9].

[1] Lee S., Sakallah K.A. (2014) Unbounded Scalable Verification Based on Approximate
Property-Directed Reachability and Datapath Abstraction. In: Biere A., Bloem R. (eds)
Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559.
Springer, Cham
[2] http://fmv.jku.at/aiger/index.html#beem
[3] http://www.cs.cmu.edu/~modelcheck/vcegar
[4] http://www.cprover.org/hardware/v2c
[5] http://github.com/aman-goel/verilogbench
[6] http://www.clifford.at/yosys
[7] http://github.com/chengyinwu/V3
[8] http://github.com/Z3Prover/z3
[9] http://github.com/SRI-CSL/yices2

id: diagonal
query-maker: "Z3"
query-time: 0.852000 ms
query-class: abstract
query-category: assume
query-type: mus_core
status: unsat
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")

; 
(set-info :status sat)
(declare-sort utt4 0)
(declare-fun z$n14s4 () utt4)
(declare-fun z$n1s4 () utt4)
(declare-fun z$n15s4 () utt4)
(declare-fun z$n0s4 () utt4)
(declare-fun X () utt4)
(declare-fun Y () utt4)
(declare-fun Y$next () utt4)
(declare-fun X$next () utt4)
(declare-fun Add_4_4_4 (utt4 utt4) utt4)
(declare-fun z$19 () utt4)
(declare-fun z$21 () utt4)
(declare-fun z$23 () utt4)
(declare-fun ShiftR_4_4_4 (utt4 utt4) utt4)
(declare-fun z$27 () utt4)
(declare-fun z$29 () utt4)
(declare-fun z$31 () utt4)
(declare-fun z$38 () utt4)
(declare-fun z$40 () utt4)
(declare-fun z$42 () utt4)
(declare-fun z$44 () utt4)
(declare-fun z$96 () utt4)
(declare-fun z$2 () Bool)
(declare-fun z$4 () Bool)
(declare-fun Le_1_4_4 (utt4 utt4) Bool)
(declare-fun z$33 () Bool)
(declare-fun z$49 () Bool)
(declare-fun prop () Bool)
(declare-fun z$50 () Bool)
(declare-fun z$60 () Bool)
(declare-fun z$62 () Bool)
(declare-fun prop$next () Bool)
(declare-fun z$63 () Bool)
(declare-fun z$68 () Bool)
(declare-fun z$69 () Bool)
(declare-fun z$71 () Bool)
(declare-fun z$67 () Bool)
(declare-fun z$70 () Bool)
(declare-fun z$35 () Bool)
(declare-fun z$109 () Bool)
(declare-fun z$111 () Bool)
(declare-fun z$86 () Bool)
(declare-fun z$108 () Bool)
(declare-fun z$110 () Bool)
(declare-fun reset_ () Bool)
(declare-fun z$8 () Bool)
(declare-fun Gr_1_4_4 (utt4 utt4) Bool)
(declare-fun z$9 () Bool)
(declare-fun z$11 () Bool)
(declare-fun z$13 () Bool)
(declare-fun z$15 () Bool)
(declare-fun z$16 () Bool)
(declare-fun z$25 () Bool)
(declare-fun z$36 () Bool)
(declare-fun z$46 () Bool)
(declare-fun z$131 () Bool)
(declare-fun z$162 () Bool)
(declare-fun z$165 () Bool)
(declare-fun z$163 () Bool)
(declare-fun z$142 () Bool)
(declare-fun z$164 () Bool)
(declare-fun z$175 () Bool)
(declare-fun z$92 () Bool)
(declare-fun z$195 () Bool)
(declare-fun z$197 () Bool)
(declare-fun z$194 () Bool)
(declare-fun z$196 () Bool)
(declare-fun reset$next () Bool)
(declare-fun p$0 () Bool)
(declare-fun p$1 () Bool)
(declare-fun z$115 () Bool)
(declare-fun p$2 () Bool)
(declare-fun p$3 () Bool)
(declare-fun p$4 () Bool)
(declare-fun z$72 () Bool)
(declare-fun p$5 () Bool)
(declare-fun z$125 () Bool)
(declare-fun p$6 () Bool)
(declare-fun z$126 () Bool)
(declare-fun p$7 () Bool)
(assert
 (and (distinct z$n0s4 z$n15s4 z$n1s4 z$n14s4) true))
(assert
 (let (($x197 (= X z$n0s4)))
 (= z$2 $x197)))
(assert
 z$2)
(assert
 (let (($x117 (= Y z$n0s4)))
 (= z$4 $x117)))
(assert
 z$4)
(assert
 (let (($x124 (Le_1_4_4 X Y)))
 (= z$33 $x124)))
(assert
 (= z$49 (not z$33)))
(assert
 (= z$50 (= prop z$49)))
(assert
 z$50)
(assert
 prop)
(assert
 (let (($x155 (Le_1_4_4 X$next Y$next)))
 (= z$60 $x155)))
(assert
 (let (($x217 (not z$60)))
 (= z$62 $x217)))
(assert
 (= z$63 (= prop$next z$62)))
(assert
 z$63)
(assert
 (let (($x114 (= Y$next z$n0s4)))
 (= z$68 $x114)))
(assert
 (= z$69 (and z$60 z$68)))
(assert
 (= z$71 (not z$69)))
(assert
 z$71)
(assert
 (= z$67 (and z$33 z$4)))
(assert
 (= z$70 (not z$67)))
(assert
 z$70)
(assert
 (let (($x218 (= Y X)))
 (= z$35 $x218)))
(assert
 (= z$109 (and z$35 z$33)))
(assert
 (= z$111 (not z$109)))
(assert
 z$111)
(assert
 (let (($x204 (= Y$next X$next)))
 (= z$86 $x204)))
(assert
 (= z$108 (and z$86 z$60)))
(assert
 (= z$110 (not z$108)))
(assert
 z$110)
(assert
 (= z$8 (not reset_)))
(assert
 (let (($x130 (Gr_1_4_4 X Y)))
 (= z$9 $x130)))
(assert
 (= z$11 (and z$8 z$9)))
(assert
 (= z$13 (not z$9)))
(assert
 (= z$15 (and (distinct X z$n15s4) true)))
(assert
 (= z$16 (or z$13 z$15)))
(assert
 (let ((?x77 (Add_4_4_4 Y z$n1s4)))
 (= z$19 ?x77)))
(assert
 (= z$21 (ite z$16 z$19 X)))
(assert
 (= z$23 (ite z$11 Y z$21)))
(assert
 (let (($x168 (= Y$next z$23)))
 (= z$25 $x168)))
(assert
 z$25)
(assert
 (let ((?x184 (ShiftR_4_4_4 z$n15s4 z$n1s4)))
 (= z$27 ?x184)))
(assert
 (let ((?x186 (ShiftR_4_4_4 X z$n1s4)))
 (= z$29 ?x186)))
(assert
 (let ((?x89 (Add_4_4_4 z$27 z$29)))
 (= z$31 ?x89)))
(assert
 (let (($x229 (or z$35 z$15)))
 (= z$36 $x229)))
(assert
 (let ((?x232 (Add_4_4_4 X z$n1s4)))
 (= z$38 ?x232)))
(assert
 (let ((?x236 (ite z$36 z$38 Y)))
 (= z$40 ?x236)))
(assert
 (= z$42 (ite z$33 X z$40)))
(assert
 (= z$44 (ite z$11 z$31 z$42)))
(assert
 (let (($x248 (= X$next z$44)))
 (= z$46 $x248)))
(assert
 z$46)
(assert
 (let (($x898 (= z$38 Y)))
 (= z$131 $x898)))
(assert
 (= z$162 (and z$2 z$4 z$131)))
(assert
 (= z$165 (not z$162)))
(assert
 z$165)
(assert
 (let (($x789 (= X$next z$n0s4)))
 (= z$163 $x789)))
(assert
 (let ((?x502 (Add_4_4_4 X$next z$n1s4)))
 (= z$96 ?x502)))
(assert
 (let (($x341 (= z$96 Y$next)))
 (= z$142 $x341)))
(assert
 (= z$164 (and z$163 z$68 z$142)))
(assert
 (= z$175 (not z$164)))
(assert
 z$175)
(assert
 (let (($x443 (Gr_1_4_4 X$next Y$next)))
 (= z$92 $x443)))
(assert
 (= z$195 (and z$163 z$92)))
(assert
 (= z$197 (not z$195)))
(assert
 z$197)
(assert
 (= z$194 (and z$2 z$9)))
(assert
 (= z$196 (not z$194)))
(assert
 z$196)
(assert
 (=> p$0 reset$next))
(assert
 (let (($x155 (Le_1_4_4 X$next Y$next)))
 (let (($x151 (= z$60 $x155)))
 (=> p$1 $x151))))
(assert
 (let (($x217 (not z$60)))
 (let (($x213 (= z$62 $x217)))
 (=> p$1 $x213))))
(assert
 (=> p$1 z$62))
(assert
 (=> p$2 (= z$115 (and (distinct Y$next X$next) true))))
(assert
 (=> p$2 z$115))
(assert
 (let (($x443 (Gr_1_4_4 X$next Y$next)))
 (let (($x1414 (= z$92 $x443)))
 (=> p$3 $x1414))))
(assert
 (=> p$3 z$92))
(assert
 (let (($x155 (Le_1_4_4 X$next Y$next)))
 (let (($x151 (= z$60 $x155)))
 (=> p$4 $x151))))
(assert
 (=> p$4 (= z$72 (not z$60))))
(assert
 (=> p$4 z$72))
(assert
 (let (($x443 (Gr_1_4_4 X$next Y$next)))
 (let (($x1414 (= z$92 $x443)))
 (=> p$5 $x1414))))
(assert
 (=> p$5 z$92))
(assert
 (=> p$6 (= z$125 (= X$next z$n15s4))))
(assert
 (=> p$6 z$125))
(assert
 (=> p$7 (= z$126 (and (distinct Y$next z$n15s4) true))))
(assert
 (=> p$7 z$126))
(check-sat)
(assert p$0)
(assert p$1)
(assert p$2)
(assert p$3)
(assert p$4)
(assert p$5)
(assert p$6)
(assert p$7)
(set-info :status unsat)
(check-sat)
(exit)
