(set-info :smt-lib-version 2.6)
(set-logic QF_UF)
(set-info :source |
Generated by: Aman Goel (amangoel@umich.edu), Karem A. Sakallah (karem@umich.edu)
Generated on: 2018-04-06

Generated by the tool Averroes 2 (successor of [1]) which implements safety property
verification on hardware systems.

This SMT problem belongs to a set of SMT problems generated by applying Averroes 2
to benchmarks derived from [2-5].

A total of 412 systems (345 from [2], 19 from [3], 26 from [4], 22 from [5]) were
syntactically converted from their original formats (using [6, 7]), and given to 
Averroes 2 to perform property checking with abstraction (wide bit-vectors -> terms, 
wide operators -> UF) using SMT solvers [8, 9].

[1] Lee S., Sakallah K.A. (2014) Unbounded Scalable Verification Based on Approximate
Property-Directed Reachability and Datapath Abstraction. In: Biere A., Bloem R. (eds)
Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559.
Springer, Cham
[2] http://fmv.jku.at/aiger/index.html#beem
[3] http://www.cs.cmu.edu/~modelcheck/vcegar
[4] http://www.cprover.org/hardware/v2c
[5] http://github.com/aman-goel/verilogbench
[6] http://www.clifford.at/yosys
[7] http://github.com/chengyinwu/V3
[8] http://github.com/Z3Prover/z3
[9] http://github.com/SRI-CSL/yices2

id: mpeg
query-maker: "Z3"
query-time: 0.411000 ms
query-class: abstract
query-category: assume
query-type: mus_min
status: sat
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")

; 
(set-info :status sat)
(declare-sort utt2 0)
(declare-sort utt3 0)
(declare-sort utt4 0)
(declare-sort utt8 0)
(declare-sort utt32 0)
(declare-sort utt31 0)
(declare-sort utt7 0)
(declare-fun z$n3s2 () utt2)
(declare-fun z$n1s2 () utt2)
(declare-fun z$n2s2 () utt2)
(declare-fun z$n0s2 () utt2)
(declare-fun z$n6s3 () utt3)
(declare-fun z$n5s3 () utt3)
(declare-fun z$n4s3 () utt3)
(declare-fun z$n1s3 () utt3)
(declare-fun z$n2s3 () utt3)
(declare-fun z$n3s3 () utt3)
(declare-fun z$n7s3 () utt3)
(declare-fun z$n0s3 () utt3)
(declare-fun z$n1s4 () utt4)
(declare-fun z$n13s4 () utt4)
(declare-fun z$n12s4 () utt4)
(declare-fun z$n11s4 () utt4)
(declare-fun z$n10s4 () utt4)
(declare-fun z$n9s4 () utt4)
(declare-fun z$n3s4 () utt4)
(declare-fun z$n2s4 () utt4)
(declare-fun z$n8s4 () utt4)
(declare-fun z$n7s4 () utt4)
(declare-fun z$n6s4 () utt4)
(declare-fun z$n5s4 () utt4)
(declare-fun z$n4s4 () utt4)
(declare-fun z$n15s4 () utt4)
(declare-fun z$n0s4 () utt4)
(declare-fun z$n15s8 () utt8)
(declare-fun z$n185s8 () utt8)
(declare-fun z$n186s8 () utt8)
(declare-fun z$n191s8 () utt8)
(declare-fun z$n3s8 () utt8)
(declare-fun z$n131s8 () utt8)
(declare-fun z$n7s8 () utt8)
(declare-fun z$n195s8 () utt8)
(declare-fun z$n67s8 () utt8)
(declare-fun z$n128s8 () utt8)
(declare-fun z$n221s8 () utt8)
(declare-fun z$n1s8 () utt8)
(declare-fun z$n93s8 () utt8)
(declare-fun z$n0s8 () utt8)
(declare-fun z$n255s8 () utt8)
(declare-fun z$n0s32 () utt32)
(declare-fun z$n1s32 () utt32)
(declare-fun mod3.state () utt3)
(declare-fun Concat_32_1_31 (Bool utt31) utt32)
(declare-fun z$n0s31 () utt31)
(declare-fun z$78 () utt32)
(declare-fun z$145 () utt32)
(declare-fun z$1038 () utt32)
(declare-fun z$1041 () utt32)
(declare-fun z$73 () utt32)
(declare-fun Extract_7_7_1_8 (utt8) utt7)
(declare-fun mod1.output_buffer () utt8)
(declare-fun z$121 () utt7)
(declare-fun Concat_8_7_1 (utt7 Bool) utt8)
(declare-fun z$124 () utt8)
(declare-fun mod1.output_buffer$next () utt8)
(declare-fun z$172 () utt3)
(declare-fun z$174 () utt3)
(declare-fun z$176 () utt3)
(declare-fun z$180 () utt3)
(declare-fun z$182 () utt3)
(declare-fun z$184 () utt3)
(declare-fun z$186 () utt3)
(declare-fun z$188 () utt3)
(declare-fun z$191 () utt3)
(declare-fun z$193 () utt3)
(declare-fun z$195 () utt3)
(declare-fun z$197 () utt3)
(declare-fun z$199 () utt3)
(declare-fun z$201 () utt3)
(declare-fun z$203 () utt3)
(declare-fun z$205 () utt3)
(declare-fun z$207 () utt3)
(declare-fun z$209 () utt3)
(declare-fun mod3.state$next () utt3)
(declare-fun z$1336 () utt7)
(declare-fun z$1338 () utt8)
(declare-fun z$1317 () Bool)
(declare-fun mod3.stop () Bool)
(declare-fun z$1025 () Bool)
(declare-fun packHeadStart () Bool)
(declare-fun z$147 () Bool)
(declare-fun z$1026 () Bool)
(declare-fun prop () Bool)
(declare-fun z$1028 () Bool)
(declare-fun mod3.stop$next () Bool)
(declare-fun z$1040 () Bool)
(declare-fun packHeadStart$next () Bool)
(declare-fun z$1043 () Bool)
(declare-fun z$1044 () Bool)
(declare-fun prop$next () Bool)
(declare-fun z$1046 () Bool)
(declare-fun z$1060 () Bool)
(declare-fun z$1061 () Bool)
(declare-fun z$1062 () Bool)
(declare-fun z$1064 () Bool)
(declare-fun z$11 () Bool)
(declare-fun z$1049 () Bool)
(declare-fun z$1059 () Bool)
(declare-fun z$1063 () Bool)
(declare-fun z$1081 () Bool)
(declare-fun z$1082 () Bool)
(declare-fun z$1084 () Bool)
(declare-fun z$1051 () Bool)
(declare-fun z$1080 () Bool)
(declare-fun z$1083 () Bool)
(declare-fun mod7.done () Bool)
(declare-fun z$76 () Bool)
(declare-fun z$80 () Bool)
(declare-fun z$82 () Bool)
(declare-fun z$84 () Bool)
(declare-fun z$86 () Bool)
(declare-fun input_stream () Bool)
(declare-fun z$126 () Bool)
(declare-fun z$167 () Bool)
(declare-fun z$149 () Bool)
(declare-fun z$168 () Bool)
(declare-fun z$170 () Bool)
(declare-fun z$179 () Bool)
(declare-fun z$190 () Bool)
(declare-fun z$9 () Bool)
(declare-fun z$211 () Bool)
(declare-fun z$1328 () Bool)
(declare-fun z$1433 () Bool)
(declare-fun z$1435 () Bool)
(declare-fun z$1335 () Bool)
(declare-fun input_stream$next () Bool)
(declare-fun z$1340 () Bool)
(declare-fun z$1434 () Bool)
(declare-fun z$1445 () Bool)
(declare-fun z$1457 () Bool)
(declare-fun z$1309 () Bool)
(declare-fun p$0 () Bool)
(declare-fun z$1310 () Bool)
(declare-fun p$1 () Bool)
(assert
 (and (distinct z$n0s2 z$n2s2 z$n1s2 z$n3s2) true))
(assert
 (and (distinct z$n0s3 z$n7s3 z$n3s3 z$n2s3 z$n1s3 z$n4s3 z$n5s3 z$n6s3) true))
(assert
 (and (distinct z$n0s4 z$n15s4 z$n4s4 z$n5s4 z$n6s4 z$n7s4 z$n8s4 z$n2s4 z$n3s4 z$n9s4 z$n10s4 z$n11s4 z$n12s4 z$n13s4 z$n1s4) true))
(assert
 (and (distinct z$n255s8 z$n0s8 z$n93s8 z$n1s8 z$n221s8 z$n128s8 z$n67s8 z$n195s8 z$n7s8 z$n131s8 z$n3s8 z$n191s8 z$n186s8 z$n185s8 z$n15s8) true))
(assert
 (and (distinct z$n1s32 z$n0s32) true))
(assert
 (= z$1317 (and (distinct mod3.state z$n3s3) true)))
(assert
 (let ((?x189 (Concat_32_1_31 mod3.stop z$n0s31)))
 (= z$78 ?x189)))
(assert
 (let (($x209 (= z$78 z$n0s32)))
 (= z$1025 $x209)))
(assert
 (let ((?x221 (Concat_32_1_31 packHeadStart z$n0s31)))
 (= z$145 ?x221)))
(assert
 (let (($x243 (= z$145 z$n1s32)))
 (= z$147 $x243)))
(assert
 (= z$1026 (and z$1025 z$147)))
(assert
 (= z$1028 (= prop z$1026)))
(assert
 (let ((?x303 (Concat_32_1_31 mod3.stop$next z$n0s31)))
 (= z$1038 ?x303)))
(assert
 (let (($x326 (= z$1038 z$n0s32)))
 (= z$1040 $x326)))
(assert
 (let ((?x379 (Concat_32_1_31 packHeadStart$next z$n0s31)))
 (= z$1041 ?x379)))
(assert
 (let (($x384 (= z$1041 z$n1s32)))
 (= z$1043 $x384)))
(assert
 (= z$1044 (and z$1040 z$1043)))
(assert
 (= z$1046 (= prop$next z$1044)))
(assert
 (= z$1060 (not mod3.stop$next)))
(assert
 (= z$1061 (and (distinct z$1038 z$n0s32) true)))
(assert
 (= z$1062 (and z$1060 z$1061)))
(assert
 (= z$1064 (not z$1062)))
(assert
 (= z$11 (not mod3.stop)))
(assert
 (= z$1049 (and (distinct z$78 z$n0s32) true)))
(assert
 (= z$1059 (and z$11 z$1049)))
(assert
 (= z$1063 (not z$1059)))
(assert
 (= z$1081 (and (distinct z$1041 z$n1s32) true)))
(assert
 (= z$1082 (and packHeadStart$next z$1081)))
(assert
 (= z$1084 (not z$1082)))
(assert
 (= z$1051 (and (distinct z$145 z$n1s32) true)))
(assert
 (= z$1080 (and packHeadStart z$1051)))
(assert
 (= z$1083 (not z$1080)))
(assert
 (let ((?x1266 (Concat_32_1_31 mod7.done z$n0s31)))
 (= z$73 ?x1266)))
(assert
 (let (($x1262 (= z$73 z$n1s32)))
 (= z$76 $x1262)))
(assert
 (let (($x1478 (= z$78 z$n1s32)))
 (= z$80 $x1478)))
(assert
 (= z$82 (ite z$80 false packHeadStart)))
(assert
 (= z$84 (ite z$76 true z$82)))
(assert
 (= z$86 (= packHeadStart$next z$84)))
(assert
 (let ((?x622 (Extract_7_7_1_8 mod1.output_buffer)))
 (= z$121 ?x622)))
(assert
 (let ((?x640 (Concat_8_7_1 z$121 input_stream)))
 (= z$124 ?x640)))
(assert
 (let (($x1333 (= mod1.output_buffer$next z$124)))
 (= z$126 $x1333)))
(assert
 (let (($x1321 (= mod3.state z$n2s3)))
 (= z$167 $x1321)))
(assert
 (let (($x1476 (= mod3.state z$n3s3)))
 (= z$149 $x1476)))
(assert
 (let (($x1490 (or z$167 z$149)))
 (= z$168 $x1490)))
(assert
 (let (($x1602 (= mod1.output_buffer z$n0s8)))
 (= z$170 $x1602)))
(assert
 (let ((?x1087 (ite z$170 z$n1s3 z$n0s3)))
 (= z$172 ?x1087)))
(assert
 (let ((?x1091 (ite z$149 z$172 z$n0s3)))
 (= z$174 ?x1091)))
(assert
 (let ((?x1096 (ite z$147 z$174 z$n0s3)))
 (= z$176 ?x1096)))
(assert
 (let (($x1035 (= mod1.output_buffer z$n1s8)))
 (= z$179 $x1035)))
(assert
 (let ((?x1486 (ite z$179 z$n3s3 z$n0s3)))
 (= z$180 ?x1486)))
(assert
 (let ((?x1102 (ite z$170 z$n1s3 z$180)))
 (= z$182 ?x1102)))
(assert
 (let ((?x1575 (ite z$167 z$182 z$n0s3)))
 (= z$184 ?x1575)))
(assert
 (let ((?x1524 (ite z$147 z$184 z$n0s3)))
 (= z$186 ?x1524)))
(assert
 (let ((?x972 (ite z$149 z$176 z$186)))
 (= z$188 ?x972)))
(assert
 (let (($x771 (= mod3.state z$n1s3)))
 (= z$190 $x771)))
(assert
 (let ((?x786 (ite z$170 z$n2s3 z$n0s3)))
 (= z$191 ?x786)))
(assert
 (let ((?x1550 (ite z$190 z$191 z$n0s3)))
 (= z$193 ?x1550)))
(assert
 (let ((?x986 (ite z$147 z$193 z$n0s3)))
 (= z$195 ?x986)))
(assert
 (let (($x1194 (= mod3.state z$n0s3)))
 (= z$9 $x1194)))
(assert
 (let ((?x856 (ite z$9 z$172 z$n0s3)))
 (= z$197 ?x856)))
(assert
 (let ((?x1346 (ite z$147 z$197 z$n0s3)))
 (= z$199 ?x1346)))
(assert
 (let ((?x1000 (ite z$9 z$199 mod3.state)))
 (= z$201 ?x1000)))
(assert
 (let ((?x1358 (ite z$190 z$195 z$201)))
 (= z$203 ?x1358)))
(assert
 (let ((?x1362 (ite z$168 z$188 z$203)))
 (= z$205 ?x1362)))
(assert
 (let ((?x1005 (ite z$147 z$205 z$n0s3)))
 (= z$207 ?x1005)))
(assert
 (let ((?x520 (ite z$147 z$207 mod3.state)))
 (= z$209 ?x520)))
(assert
 (let (($x1378 (= mod3.state$next z$209)))
 (= z$211 $x1378)))
(assert
 (let (($x1916 (= z$124 z$n93s8)))
 (= z$1328 $x1916)))
(assert
 (= z$1433 (and z$179 z$1328)))
(assert
 (= z$1435 (not z$1433)))
(assert
 (let (($x1126 (= mod1.output_buffer$next z$n1s8)))
 (= z$1335 $x1126)))
(assert
 (let ((?x930 (Extract_7_7_1_8 mod1.output_buffer$next)))
 (= z$1336 ?x930)))
(assert
 (let ((?x1419 (Concat_8_7_1 z$1336 input_stream$next)))
 (= z$1338 ?x1419)))
(assert
 (let (($x888 (= z$1338 z$n93s8)))
 (= z$1340 $x888)))
(assert
 (= z$1434 (and z$1335 z$1340)))
(assert
 (= z$1445 (not z$1434)))
(assert
 (let (($x1169 (and z$1317 z$1028 prop z$1046 z$1064 z$1063 z$1084 z$1083 z$86 z$126 z$211 z$1435 z$1445)))
 (= z$1457 $x1169)))
(assert
 z$1457)
(assert
 (=> p$0 (= z$1309 (= mod3.state$next z$n3s3))))
(assert
 (=> p$0 z$1309))
(assert
 (=> p$1 (= z$1310 (= mod1.output_buffer$next z$n93s8))))
(assert
 (=> p$1 z$1310))
(check-sat)
(assert p$0)
(set-info :status sat)
(check-sat)
(exit)
