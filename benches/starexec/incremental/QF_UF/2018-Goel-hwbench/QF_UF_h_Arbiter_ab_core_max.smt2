(set-info :smt-lib-version 2.6)
(set-logic QF_UF)
(set-info :source |
Generated by: Aman Goel (amangoel@umich.edu), Karem A. Sakallah (karem@umich.edu)
Generated on: 2018-04-06

Generated by the tool Averroes 2 (successor of [1]) which implements safety property
verification on hardware systems.

This SMT problem belongs to a set of SMT problems generated by applying Averroes 2
to benchmarks derived from [2-5].

A total of 412 systems (345 from [2], 19 from [3], 26 from [4], 22 from [5]) were
syntactically converted from their original formats (using [6, 7]), and given to 
Averroes 2 to perform property checking with abstraction (wide bit-vectors -> terms, 
wide operators -> UF) using SMT solvers [8, 9].

[1] Lee S., Sakallah K.A. (2014) Unbounded Scalable Verification Based on Approximate
Property-Directed Reachability and Datapath Abstraction. In: Biere A., Bloem R. (eds)
Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559.
Springer, Cham
[2] http://fmv.jku.at/aiger/index.html#beem
[3] http://www.cs.cmu.edu/~modelcheck/vcegar
[4] http://www.cprover.org/hardware/v2c
[5] http://github.com/aman-goel/verilogbench
[6] http://www.clifford.at/yosys
[7] http://github.com/chengyinwu/V3
[8] http://github.com/Z3Prover/z3
[9] http://github.com/SRI-CSL/yices2

id: h_Arbiter
query-maker: "Z3"
query-time: 1.137000 ms
query-class: abstract
query-category: assume
query-type: mus_core
status: unsat
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")

; 
(set-info :status sat)
(declare-sort utt2 0)
(declare-sort utt32 0)
(declare-sort utt31 0)
(declare-sort utt30 0)
(declare-fun z$n3s2 () utt2)
(declare-fun z$n2s2 () utt2)
(declare-fun z$n1s2 () utt2)
(declare-fun z$n0s2 () utt2)
(declare-fun z$n0s32 () utt32)
(declare-fun z$n1s32 () utt32)
(declare-fun z$n3s32 () utt32)
(declare-fun arbiter.state () utt2)
(declare-fun clientA.state () utt2)
(declare-fun clientB.state () utt2)
(declare-fun clientC.state () utt2)
(declare-fun controllerA.state () utt2)
(declare-fun controllerB.state () utt2)
(declare-fun controllerC.state () utt2)
(declare-fun Concat_32_1_31 (Bool utt31) utt32)
(declare-fun z$n0s31 () utt31)
(declare-fun z$331 () utt32)
(declare-fun z$335 () utt32)
(declare-fun z$340 () utt32)
(declare-fun z$362 () utt32)
(declare-fun z$365 () utt32)
(declare-fun z$370 () utt32)
(declare-fun z$250 () utt2)
(declare-fun z$252 () utt2)
(declare-fun z$254 () utt2)
(declare-fun Concat_32_2_30 (utt2 utt30) utt32)
(declare-fun z$n0s30 () utt30)
(declare-fun z$163 () utt32)
(declare-fun z$166 () utt32)
(declare-fun z$172 () utt2)
(declare-fun Extract_2_1_0_32 (utt32) utt2)
(declare-fun z$168 () utt2)
(declare-fun z$256 () utt2)
(declare-fun z$258 () utt2)
(declare-fun z$260 () utt2)
(declare-fun z$262 () utt2)
(declare-fun z$264 () utt2)
(declare-fun z$266 () utt2)
(declare-fun z$268 () utt2)
(declare-fun controllerB.state$next () utt2)
(declare-fun z$307 () utt2)
(declare-fun z$309 () utt2)
(declare-fun z$311 () utt2)
(declare-fun z$313 () utt2)
(declare-fun z$315 () utt2)
(declare-fun z$317 () utt2)
(declare-fun z$319 () utt2)
(declare-fun z$321 () utt2)
(declare-fun z$323 () utt2)
(declare-fun z$325 () utt2)
(declare-fun controllerC.state$next () utt2)
(declare-fun z$2 () Bool)
(declare-fun clientA.req () Bool)
(declare-fun z$4 () Bool)
(declare-fun z$6 () Bool)
(declare-fun clientB.req () Bool)
(declare-fun z$8 () Bool)
(declare-fun z$10 () Bool)
(declare-fun clientC.req () Bool)
(declare-fun z$12 () Bool)
(declare-fun z$14 () Bool)
(declare-fun controllerA.ack () Bool)
(declare-fun z$16 () Bool)
(declare-fun controllerA.pass_token () Bool)
(declare-fun z$19 () Bool)
(declare-fun controllerB.ack () Bool)
(declare-fun z$21 () Bool)
(declare-fun controllerB.pass_token () Bool)
(declare-fun z$24 () Bool)
(declare-fun controllerC.ack () Bool)
(declare-fun z$26 () Bool)
(declare-fun controllerC.pass_token () Bool)
(declare-fun z$29 () Bool)
(declare-fun z$334 () Bool)
(declare-fun z$337 () Bool)
(declare-fun z$338 () Bool)
(declare-fun z$342 () Bool)
(declare-fun z$343 () Bool)
(declare-fun z$345 () Bool)
(declare-fun z$347 () Bool)
(declare-fun z$349 () Bool)
(declare-fun z$351 () Bool)
(declare-fun prop () Bool)
(declare-fun z$352 () Bool)
(declare-fun controllerA.ack$next () Bool)
(declare-fun z$364 () Bool)
(declare-fun controllerB.ack$next () Bool)
(declare-fun z$367 () Bool)
(declare-fun z$368 () Bool)
(declare-fun controllerC.ack$next () Bool)
(declare-fun z$372 () Bool)
(declare-fun z$373 () Bool)
(declare-fun z$375 () Bool)
(declare-fun z$377 () Bool)
(declare-fun z$379 () Bool)
(declare-fun z$381 () Bool)
(declare-fun prop$next () Bool)
(declare-fun z$382 () Bool)
(declare-fun z$389 () Bool)
(declare-fun z$390 () Bool)
(declare-fun z$392 () Bool)
(declare-fun z$388 () Bool)
(declare-fun z$391 () Bool)
(declare-fun z$220 () Bool)
(declare-fun z$215 () Bool)
(declare-fun z$248 () Bool)
(declare-fun z$32 () Bool)
(declare-fun z$34 () Bool)
(declare-fun z$231 () Bool)
(declare-fun z$270 () Bool)
(declare-fun z$277 () Bool)
(declare-fun z$272 () Bool)
(declare-fun z$305 () Bool)
(declare-fun z$288 () Bool)
(declare-fun z$327 () Bool)
(declare-fun z$85 () Bool)
(declare-fun z$86 () Bool)
(declare-fun z$88 () Bool)
(declare-fun z$90 () Bool)
(declare-fun z$92 () Bool)
(declare-fun clientB.req$next () Bool)
(declare-fun z$94 () Bool)
(declare-fun z$216 () Bool)
(declare-fun z$218 () Bool)
(declare-fun z$221 () Bool)
(declare-fun z$223 () Bool)
(declare-fun z$225 () Bool)
(declare-fun p$0 () Bool)
(declare-fun p$1 () Bool)
(declare-fun p$2 () Bool)
(declare-fun z$462 () Bool)
(declare-fun p$3 () Bool)
(declare-fun z$472 () Bool)
(declare-fun p$4 () Bool)
(assert
 (and (distinct z$n0s2 z$n1s2 z$n2s2 z$n3s2) true))
(assert
 (and (distinct z$n3s32 z$n1s32 z$n0s32) true))
(assert
 (let (($x1102 (= arbiter.state z$n0s2)))
 (= z$2 $x1102)))
(assert
 z$2)
(assert
 (= z$4 (not clientA.req)))
(assert
 z$4)
(assert
 (let (($x1098 (= clientA.state z$n0s2)))
 (= z$6 $x1098)))
(assert
 z$6)
(assert
 (= z$8 (not clientB.req)))
(assert
 z$8)
(assert
 (let (($x1094 (= clientB.state z$n0s2)))
 (= z$10 $x1094)))
(assert
 z$10)
(assert
 (= z$12 (not clientC.req)))
(assert
 z$12)
(assert
 (let (($x1090 (= clientC.state z$n0s2)))
 (= z$14 $x1090)))
(assert
 z$14)
(assert
 (= z$16 (not controllerA.ack)))
(assert
 z$16)
(assert
 controllerA.pass_token)
(assert
 (let (($x590 (= controllerA.state z$n0s2)))
 (= z$19 $x590)))
(assert
 z$19)
(assert
 (= z$21 (not controllerB.ack)))
(assert
 z$21)
(assert
 controllerB.pass_token)
(assert
 (let (($x586 (= controllerB.state z$n0s2)))
 (= z$24 $x586)))
(assert
 z$24)
(assert
 (= z$26 (not controllerC.ack)))
(assert
 z$26)
(assert
 controllerC.pass_token)
(assert
 (let (($x582 (= controllerC.state z$n0s2)))
 (= z$29 $x582)))
(assert
 z$29)
(assert
 (= z$331 (Concat_32_1_31 controllerA.ack z$n0s31)))
(assert
 (let (($x250 (= z$331 z$n1s32)))
 (= z$334 $x250)))
(assert
 (= z$335 (Concat_32_1_31 controllerB.ack z$n0s31)))
(assert
 (let (($x208 (= z$335 z$n1s32)))
 (= z$337 $x208)))
(assert
 (= z$338 (and z$334 z$337)))
(assert
 (= z$340 (Concat_32_1_31 controllerC.ack z$n0s31)))
(assert
 (let (($x174 (= z$340 z$n1s32)))
 (= z$342 $x174)))
(assert
 (= z$343 (and z$337 z$342)))
(assert
 (= z$345 (or z$338 z$343)))
(assert
 (= z$347 (and z$342 z$334)))
(assert
 (= z$349 (or z$345 z$347)))
(assert
 (= z$351 (not z$349)))
(assert
 (= z$352 (= prop z$351)))
(assert
 z$352)
(assert
 prop)
(assert
 (let ((?x61 (Concat_32_1_31 controllerA.ack$next z$n0s31)))
 (= z$362 ?x61)))
(assert
 (let (($x44 (= z$362 z$n1s32)))
 (= z$364 $x44)))
(assert
 (let ((?x26 (Concat_32_1_31 controllerB.ack$next z$n0s31)))
 (= z$365 ?x26)))
(assert
 (let (($x531 (= z$365 z$n1s32)))
 (= z$367 $x531)))
(assert
 (= z$368 (and z$364 z$367)))
(assert
 (let ((?x562 (Concat_32_1_31 controllerC.ack$next z$n0s31)))
 (= z$370 ?x562)))
(assert
 (let (($x560 (= z$370 z$n1s32)))
 (= z$372 $x560)))
(assert
 (= z$373 (and z$367 z$372)))
(assert
 (let (($x954 (or z$368 z$373)))
 (= z$375 $x954)))
(assert
 (= z$377 (and z$372 z$364)))
(assert
 (let (($x958 (or z$375 z$377)))
 (= z$379 $x958)))
(assert
 (= z$381 (not z$379)))
(assert
 (= z$382 (= prop$next z$381)))
(assert
 z$382)
(assert
 (= z$389 (not controllerA.ack$next)))
(assert
 (= z$390 (and z$364 z$389)))
(assert
 (= z$392 (not z$390)))
(assert
 z$392)
(assert
 (= z$388 (and z$334 z$16)))
(assert
 (= z$391 (not z$388)))
(assert
 z$391)
(assert
 (let (($x1076 (= controllerB.state z$n1s2)))
 (= z$220 $x1076)))
(assert
 (let (($x577 (= controllerB.state z$n2s2)))
 (= z$215 $x577)))
(assert
 (let (($x359 (or z$220 z$215)))
 (= z$248 $x359)))
(assert
 (= z$250 (ite z$8 z$n0s2 controllerB.state)))
(assert
 (let ((?x353 (ite z$215 z$250 z$n0s2)))
 (= z$252 ?x353)))
(assert
 (let ((?x354 (ite z$215 z$252 z$n2s2)))
 (= z$254 ?x354)))
(assert
 (= z$32 (or controllerA.pass_token controllerB.pass_token)))
(assert
 (= z$34 (or z$32 controllerC.pass_token)))
(assert
 (let ((?x688 (Concat_32_2_30 arbiter.state z$n0s30)))
 (= z$163 ?x688)))
(assert
 (= z$166 (ite z$34 z$163 z$n3s32)))
(assert
 (= z$172 (ite z$34 arbiter.state z$n3s2)))
(assert
 (let ((?x677 (Extract_2_1_0_32 z$166)))
 (= z$168 ?x677)))
(assert
 (= z$168 z$172))
(assert
 (let (($x672 (= z$168 z$n1s2)))
 (= z$231 $x672)))
(assert
 (= z$256 (ite clientB.req z$n1s2 controllerB.state)))
(assert
 (let ((?x328 (ite z$231 z$256 z$n0s2)))
 (= z$258 ?x328)))
(assert
 (= z$260 (ite z$24 z$258 z$n0s2)))
(assert
 (let ((?x771 (ite z$231 z$260 controllerB.state)))
 (= z$262 ?x771)))
(assert
 (= z$264 (ite z$24 z$262 z$n0s2)))
(assert
 (= z$266 (ite z$24 z$264 controllerB.state)))
(assert
 (let ((?x777 (ite z$248 z$254 z$266)))
 (= z$268 ?x777)))
(assert
 (let (($x779 (= controllerB.state$next z$268)))
 (= z$270 $x779)))
(assert
 z$270)
(assert
 (let (($x781 (= controllerC.state z$n1s2)))
 (= z$277 $x781)))
(assert
 (let (($x286 (= controllerC.state z$n2s2)))
 (= z$272 $x286)))
(assert
 (let (($x784 (or z$277 z$272)))
 (= z$305 $x784)))
(assert
 (= z$307 (ite z$12 z$n0s2 controllerC.state)))
(assert
 (let ((?x788 (ite z$272 z$307 z$n0s2)))
 (= z$309 ?x788)))
(assert
 (let ((?x790 (ite z$272 z$309 z$n2s2)))
 (= z$311 ?x790)))
(assert
 (let (($x422 (= z$168 z$n2s2)))
 (= z$288 $x422)))
(assert
 (= z$313 (ite clientC.req z$n1s2 controllerC.state)))
(assert
 (let ((?x443 (ite z$288 z$313 z$n0s2)))
 (= z$315 ?x443)))
(assert
 (= z$317 (ite z$29 z$315 z$n0s2)))
(assert
 (let ((?x309 (ite z$288 z$317 controllerC.state)))
 (= z$319 ?x309)))
(assert
 (= z$321 (ite z$29 z$319 z$n0s2)))
(assert
 (= z$323 (ite z$29 z$321 controllerC.state)))
(assert
 (let ((?x317 (ite z$305 z$311 z$323)))
 (= z$325 ?x317)))
(assert
 (let (($x491 (= controllerC.state$next z$325)))
 (= z$327 $x491)))
(assert
 z$327)
(assert
 (let (($x516 (= clientB.state z$n2s2)))
 (= z$85 $x516)))
(assert
 (= z$86 (ite z$85 clientB.req false)))
(assert
 (= z$88 (ite z$10 clientB.req false)))
(assert
 (= z$90 (ite z$10 z$88 clientB.req)))
(assert
 (= z$92 (ite z$85 z$86 z$90)))
(assert
 (= z$94 (= clientB.req$next z$92)))
(assert
 z$94)
(assert
 (= z$216 (ite z$8 false controllerB.ack)))
(assert
 (= z$218 (ite z$215 z$216 false)))
(assert
 (= z$221 (ite z$220 true controllerB.ack)))
(assert
 (= z$223 (ite z$215 z$218 z$221)))
(assert
 (= z$225 (= controllerB.ack$next z$223)))
(assert
 z$225)
(assert
 (=> p$0 clientB.req$next))
(assert
 (=> p$1 controllerB.ack$next))
(assert
 (let ((?x26 (Concat_32_1_31 controllerB.ack$next z$n0s31)))
 (let (($x25 (= z$365 ?x26)))
 (=> p$2 $x25))))
(assert
 (let (($x531 (= z$365 z$n1s32)))
 (let (($x945 (= z$367 $x531)))
 (=> p$2 $x945))))
(assert
 (=> p$2 z$367))
(assert
 (=> p$3 (= z$462 (= controllerC.state$next z$n1s2))))
(assert
 (=> p$3 z$462))
(assert
 (=> p$4 (= z$472 (= controllerB.state$next z$n2s2))))
(assert
 (=> p$4 z$472))
(check-sat)
(assert p$0)
(assert p$1)
(assert p$2)
(assert p$3)
(assert p$4)
(set-info :status unsat)
(check-sat)
(exit)
